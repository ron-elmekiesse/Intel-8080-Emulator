#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "utils.h"

CPU cpu = { 0 };
char stack[STACK_SIZE] = { 0 };
BYTE* data = NULL;

int open_file(FILE** fd)
{
	char path[MAX_PATH] = { 0 };
	char* ptr = NULL;

	printf("Enter File path:\n");
	fgets(path, MAX_PATH, stdin);

	ptr = strchr(path, '\n');
	if (ptr)
		*ptr = '\0';

	*fd = fopen(path, "rb");
	if (!*fd)
	{
		printf("Invalid path!\n");
		return -1;
	}
	printf("Opened the file succefully!\n");
	return 0;
}

int get_file_size(FILE* fd)
{
	fseek(fd, 0, SEEK_END);
	int size = ftell(fd);
	fseek(fd, 0, SEEK_SET);
	return size;
}

int get_register_ptr(char reg, UINT8** out)
{
	switch (reg)
	{
			case 'A':
				*out = &cpu.A;
				break;
			case 'B':
				*out = &cpu.B;
				break;
			case 'C':
				*out = &cpu.C;
				break;
			case 'D':
				*out = &cpu.D;
				break;
			case 'E':
				*out = &cpu.E;
				break;
			case 'H':
				*out = &cpu.H;
				break;
			case 'L':
				*out = &cpu.L;
				break;
			case 'M':
				*out = &cpu.H; // M refers to the memory address pointed to by the HL pair.
				break;
			default:
				printf("Invalid register!\n");
				return -1;
				break;
	}
	return 0;
}

int set_bit(unsigned int bit_index, unsigned int bit_val, char* num)
{
	int h = 1;

	h = h << bit_index;

	// If we need to change the flag from the current state.
	// If the flag state is the same as asked we do not need to make an change to it.
	if (((*num) & h) == 0 && bit_val == 1)
	{
		(*num) = (*num) | h; // Turn on.
	}
	else if (((*num) & h) > 0 && bit_val == 0)
	{
		(*num) = (*num) ^ h; // Turn off
	}

	return 0;
}

int get_bit_state(unsigned int bit_index, char* num)
{
	int h = 1;
	
	h = h << bit_index;

	if (((*num) & h) == 0)
		return 0;
	return 1;
}

char* get_regs_from_instruction(char* instruction)
{
	char* temp_instruction = (char*)malloc(strlen(instruction) + 1);
	char* token = NULL;

	if (!temp_instruction)
		return; // if malloc failed
	
	strncpy(temp_instruction, instruction, strlen(instruction) + 1);

	temp_instruction[strlen(instruction)] = '\0';
	token = strtok(temp_instruction, SPACE_DELIM);
	token = strtok(NULL, SPACE_DELIM); // Get registers.

	token = _strdup(token);

	free(temp_instruction);

	return token;
}

void Push_PC()
{
	//*(long*)(cpu.SP + 1) = cpu.PC; // Another way to implement the memcpy
	memcpy((cpu.SP + 1), &cpu.PC, sizeof(cpu.PC)); // copy 4 bytes representing the address to the stack.

	cpu.SP += sizeof(cpu.PC); // 4 bytes
}

void Pop_PC()
{
	//cpu.PC = *(long*)(cpu.SP - sizeof(long) + 1); // same as the memcpy.
	memcpy(&cpu.PC, cpu.SP - sizeof(long) + 1, sizeof(cpu.PC));

	cpu.SP -= sizeof(cpu.PC);
}

// It is possible to treat a byte of data as having the numerical range -128 to +127 In this case, by
// convention, the 7 bit will always represent the sign of the number;
// That is, if the 7 bit is 1, the number is in the range -128 to -1.
// If bit 7 is 0, the number is in the range 0 to +127
// To conclude: the Sign bit will be set to the condition of the most significant bit of the answer (bit 7).
void handle_Sign_Flag(UINT8 result)
{
	set_bit(SIGN, get_bit_state(7, &result), &cpu.Flags);
}

// The Zero Flag is set (1) if the result generated by the execution of certain instructions is zero.
// The Zero bit is reset (0) if the result is not zero.
void handle_Zero_Flag(int result)
{
	if (result == 0)
		set_bit(ZERO, 1, &cpu.Flags);
	else
		set_bit(ZERO, 0, &cpu.Flags);
}

// The Auxiliary Carry bit indicates carry out of bit 3 (index 3, 4th place -> out of the first nibble).
// It indicates when a carry or borrow has been generated out of the least significant four bits.
// The Auxiliary flag is set (to 1) if during an "add" operation there is a carry from the low nibble (lowest four bits) to the high nibble
// (upper four bits),
// or a borrow from the high nibble to the low nibble, during a subtraction.
// Otherwise, if no such carry or borrow occurs, the flag is cleared or "reset" (set to 0).
void handle_Auxiliary_Carry_Flag(int val1, int val2, char operation)
{
	int nibble1 = val1 & 0xf, nibble2 = val2 & 0xf; // nibble is 4 bits - 1 hex char
	int new_state = 0;

	switch (operation)
	{
	case '+':
		if (nibble1 + nibble2 > 0xf) // if carry was done.
			new_state = 1;
		break;
	case '-':
		if (nibble1 - nibble2 < 0) // if borrow was done.
			new_state = 1;
		break;
	case '^': // just set flag to 0:
		break;
	case '&':
		break;
	case '|':
		break;
	default:
		printf("Invalid operation to handle Auxiliary Carry Flag!\n");
		break;
	}

	set_bit(AUXILIARY_CARRY, new_state, &cpu.Flags);
}

// The number of 1 bits in a byte are counted, then:
// Parity Flag is set (1) if the total numbers of 1 bits in the result is even
// and is reset to 0 if the total is odd.
void handle_Parity_Flag(BYTE result)
{
	int counter = 0;
	for (int i = 0; i < 8; i++) // BYTE is 1 byte size (= 8 bits)
	{
		if (result & 1)
			counter++;
		result >>= 1;
	}

	if (counter % 2 == 0) // if even
		set_bit(PARITY, 1, &cpu.Flags);
	else // if odd
		set_bit(PARITY, 0, &cpu.Flags);
}

// Sets (1) if the last addition operation resulted in a carry or if the last subtraction operation required a borrow.
// When performing an addition operation, the Carry bit is set (1) when the result is greater than 255D.
// When performing subtraction, the Carry bit is reset (0) when the result is positive.
// If the Carry bit is set (1), the result is negative and present in its two's complement form (see intel 8080 Manual).
// Thus, the Carry bit when set (1) indicates the occurrence of a "borrow".
// size_of_data_type -> 1 (for char), 2 (for short), etc...
void handle_Carry_Flag(int val1, int val2, char operation, int size_of_data_type)
{
	int result = 0;
	int sign_bit_index = size_of_data_type == sizeof(UINT8) ? 7 : 15;

	// short or uint8 val not int -->> just to allign the values.
	val1 = val1 & ((1 << (8 * size_of_data_type)) - 1);
	val2 = val2 & ((1 << (8 * size_of_data_type)) - 1);
	
	// checking for a borrow and calculating the result for next checking.
	switch (operation)
	{
	case '+':
	// When different signs and when the absolute of the signed num is bigger than the other.
		// ***** TODO: maybe there's no need to check!!!!!! *****
		if (get_bit_state(sign_bit_index, &val1) == 1 && get_bit_state(sign_bit_index, &val2) == 0 && abs(val1) > val2)
		{
			set_bit(CARRY, 1, &cpu.Flags);
			return;
		}
		else if (get_bit_state(sign_bit_index, &val2) == 1 && get_bit_state(sign_bit_index, &val1) == 0 && abs(val2) > val1)
		{
			set_bit(CARRY, 1, &cpu.Flags);
			return;
		}
		result = val1 + val2;
		break;
	case '-':
		// if both positive numbers and the val2 is bigger than val1.
		/*if (get_bit_state(sign_bit_index, &val1) == 0 && get_bit_state(sign_bit_index, &val2) == 0 && val2 > val1)
		{
			set_bit(CARRY, 1, &cpu.Flags);
			return;
		}*/
		if ((unsigned int)val2 > (unsigned int)val1)
		{
			set_bit(CARRY, 1, &cpu.Flags);
			return;
		}
		result = val1 - val2;
		break;
	default:
		printf("Invalid operator given: %c\n", operation);
		break;
	}

	// if the last operation resulted in a carry -->> if result is bigger than 255 (0xff - char) or bigger than (0xffff - short).
	if (((unsigned int)result >> (size_of_data_type * 8)) > 0)
	{
		set_bit(CARRY, 1, &cpu.Flags);
		return;
	}


	// if none of these occourred we reset (0) the Carry Flag.
	set_bit(CARRY, 0, &cpu.Flags);
}

// This function get an array of flags to check and extra values.
// We call the flag handler with it's speicifed valued.
void handle_FLAGS(int result, int val1, int val2, char operation, int size_of_data_type,
	int check_SIGN, int check_ZERO, int check_AUXILIARY_CARRY, int check_PARITY, int check_CARRY)
{
	if (check_SIGN == SIGN)
		handle_Sign_Flag(result);
	if (check_ZERO == ZERO)
		handle_Zero_Flag(result);
	if (check_AUXILIARY_CARRY == AUXILIARY_CARRY)
		handle_Auxiliary_Carry_Flag(val1, val2, operation);
	if (check_PARITY == PARITY)
		handle_Parity_Flag((BYTE)result);
	if (check_CARRY == CARRY)
		handle_Carry_Flag(val1, val2, operation, size_of_data_type);
}